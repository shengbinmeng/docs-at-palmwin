新的网络控制算法

# 统计信息的保存

对每个报告，都执行下述的保存报告数据（store_report_data）操作。

将客户端报告的统计信息数据，保存在一个列表中，称为“报告列表”。该列表的最终长度为50，每次报告的间隔为200ms，所以我们保存了过去10s内的统计信息。

在插入列表时，我们按seq_no来排序插入；这样可以保证按时间顺序来保存，避免UDP传输时乱序的影响。

每次报告里既有当前200ms间隔内精细到包的详细数据，也有这200ms内的汇总数据。汇总数据可以由详细数据计算得到。我们只保存汇总数据（使用时也只使用汇总数据）。

当前报告还包含了过去5个间隔内的汇总数据。这是一种冗余保证措施，在某个报告丢失时，可以用后续报告中的相应内容补上。

# 统计信息的利用

每隔两个报告（400ms，这称之为控制单位或控制精度），执行一次控制操作（control_peer），包括决定带宽和决定丢包率两个独立的部分。

## 决定带宽（decide_bandwidth）

依次执行下述两部分。

### 码率值的计算和保存

用报告列表最后5个报告的接收汇总数据，来计算当前这1s内的平均接收码率bitrate_receivng。

获得当前的发送码率bitrate_sending；获得的方法包括：1，直接用报告来的sendBitrate；2，自己从报告的发送汇总数据计算。目前使用了1。

计算码率差值：bitrate_diff = bitrate_receivng - bitrate_sending。

将上述获得的码率值保存在一个列表中，称为“码率列表”。这个列表的最终长度为50，每个列表项对应1s内的码率，所以该列表保存了过去50s内的码率信息。

（其实码率差值可以随时计算得到，并没必要保存。）

### 利用码率值来估计带宽

目前我们只利用了码率差值（bitrate_diff）。用在下述PID控制模型中。

将码率列表中的最后一个码率差值，作为E_p。
将码率列表中所有码率差值的累加和，作为E_i。
用码率列表中的最后一个码率差值减去倒数第二个码率差值，作为E_d。

计算increase = K_p * E_p + K_i * E_i + K_d * E_d，其中K_p、K_i、K_d是可调系数。目前我们取K_p = 1，K_i = 0，K_d = 0，这样相当于只用了E_p部分。

将估计的带宽定为：上次决定的带宽（last_decided_bandwidth）加上increase。

### 由估计值到决定值

估计的带宽做上下限截断和以32为步长的量化，得到决定的带宽。

## 决定丢包率（decide_packet_loss）

用报告列表最后5个报告的接收汇总数据，来计算这1s内的平均丢包率。

目前就以此作为估计的丢包率，也是决定的丢包率。

不应该用每次报告（200ms内）的汇总数据计算一个丢包率，然后将它们平均。因为200ms内包数很少，导致很多包在计算间隔的边界。
而以下情况将使得计算的丢包率不符合实际：1）在间隔边界的包丢了；2）发生乱序且乱序的包跨过了间隔边界才收到（下一个包未跨边界）。
应该增大计算间隔以减少边界包所占比例。

# TODO

目前完全没有涉及每个包的具体传输时间。后面可以加上对这些信息的利用。首先要确保包的传输时间值有意义；其次要考虑这种精细粒度的值如何对应到统计意义上的带宽。

可以再加以利用的信息有：报告来的每个数据包的发送和接收时间戳，报告来的RTT。

可将以上各种因素综合起来考虑。