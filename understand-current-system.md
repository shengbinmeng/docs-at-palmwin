当前传输系统的理解

# 总体架构

客户端A（self）向服务器S发送统计信息(stat_info)，S分析总结这些信息，做出决策结果(result_set)，反馈给与A通话的客户端B（peer），指导其进行媒体数据发送的配置（例如，设定视频编码码率，进行FEC）。

# 媒体数据传输的两种方式

1. A与B以P2P方式直连，媒体数据直接由A传到B；
2. 媒体数据经S中转（relay），即先由A传到S，再由S传到B。

对于两人通话，1和2均可用（初始需选择一个）；且传输方式在初始决定后，后面可根据网络情况切换。对于群聊，只采用了2。

对于群聊，在S上设置两个虚拟客户端a和b，分别作为A和B的peer；A->a和b->B按两个传输段分别对待。
对于两人通话中的2方式，服务器只起到数据中转的作用，并无虚拟客户端来统计信息，仍只有A->B这一个传输段。

# 统计信息

统计信息stat_info每固定时间间隔（T＝200ms）汇报一次。其中的数据包括：

- 这T时间内所有发送的数据包信息（sendpacketinfo_list）; // 该list长度限为了200
- 这T时间内所有接收的数据包信息（recpacketinfo_list）; // 该list长度限为了200
- 这T时间内及过去N个T时间内发送数据包情况的总结信息（sendsummaryinfo_list）; // 该list长度限为了5（即N为5）
- 这T时间内及过去N个T时间内接收数据包情况的总结信息（recsummaryinfo_list)。// 该list长度限为了5

每个数据包信息包括：包号、包大小、包的发送时间和接收时间；
每个T时间内的总结信息包括：这段时间内所有包的最大包号、最小包号、总大小、总数量、总传输时间（每个包的传输时间为接收时间与发送时间之差）。

stat_info中还包括：当前实际发送的码率（sendBitrate）、网络类型（net_type，是Wi-Fi还是3G等）、p2p和relay两种传输方式的RTT，等等。

这里的统计数据统计了一个UDP信道上发的所有数据包，包含音频包、视频包、甚至可能包含这些信息包本身（？）

# 统计信息的收集和使用

对于实体客户端A和B，由客户端机器收集统计信息发送给服务器S；对于虚拟客户端a和b，由服务器S收集统计信息交给自己。

统计信息和决策结果（统称控制数据）与媒体数据一样，都是用UDP传输的，可能丢掉。// 其实这些控制数据更重要些，可以用更靠谱的传输方式；目前的实现主要考虑方便和及时性

如果有媒体数据通道，控制数据就与其共用一个通道（顺路嘛）；否则就自己开一个通道（比如媒体数据走P2P而控制数据自己要去服务器的情况）。

统计信息在服务器S上的网络控制模块中使用。

# 网络控制模块

该模块的输入为self定时汇报来的统计信息，其输出为不时传给peer的决策结果。

决策结果包括：应发送的码率（对当前网络带宽的估计），应进行FEC的冗余率（对当前网络丢包率的估计），应采用的传输方式（P2P还是relay）。

因为决策结果很重要但用UDP传输可能丢包，故重复发送多次以尽可能确保送到。

决策结果通过JSON字符串编码后封包发送给客户端。目前该JSON字符串的格式协定为：

{"bw":%d,"plr":%d,"bwub":%d,"bwdb":%d,"bwd":%d}

其中bw表示带宽，plr表示丢包率，bwub、bwdb、bwd分别表示带宽上限、下限、变化量。后三个值是另一套方法，现在已经弃用。

（应采用的传输方式目前并未通过JSON字符串传给客户端；即还不支持）

# 客户端对决策结果的使用

## 对当前总带宽的估计值

客户端会先将其减去音频固定码率（例如16K），然后做特定的转换（主要是量化和限制），然后得到targetBitrate送给视频编码器。

上述“限制”包括由UI（例如视频显示窗口的大小）决定的上下限。

targetBitrate送给编码器后，编码器目前采用ABR（Average Bitrate） 模式来编码，送给它的值只是平均值，编码器会根据场景情况编出与其差别可能很大的实际码率值。

（目前统计信息中的sendBitrate只是被赋为了上述的targetBitrate，传给了服务器）

## 对当前丢包率的估计

这本是基于包含音视频、控制信息在内的所有数据包得出的；客户端依据它仅对编出的视频数据做FEC。

## 应采用的传输方式

目前这块儿并未启用，甚至根本没通过JSON字符串传过来。